\n\t  var Data, Directory,\n\t    __slice = [].slice;\n\n\t  Data = __webpack_require__(72);\n\n\t  Directory = (function() {\n\t    var checksum;\n\n\t    function Directory(data) {\n\t      var entry, i, _i, _ref;\n\t      this.scalarType = data.readInt();\n\t      this.tableCount = data.readShort();\n\t      this.searchRange = data.readShort();\n\t      this.entrySelector = data.readShort();\n\t      this.rangeShift = data.readShort();\n\t      this.tables = {};\n\t      for (i = _i = 0, _ref = this.tableCount; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n\t        entry = {\n\t          tag: data.readString(4),\n\t          checksum: data.readInt(),\n\t          offset: data.readInt(),\n\t          length: data.readInt()\n\t        };\n\t        this.tables[entry.tag] = entry;\n\t      }\n\t    }\n\n\t    Directory.prototype.encode = function(tables) {\n\t      var adjustment, directory, directoryLength, entrySelector, headOffset, log2, offset, rangeShift, searchRange, sum, table, tableCount, tableData, tag;\n\t      tableCount = Object.keys(tables).length;\n\t      log2 = Math.log(2);\n\t      searchRange = Math.floor(Math.log(tableCount) / log2) * 16;\n\t      entrySelector = Math.floor(searchRange / log2);\n\t      rangeShift = tableCount * 16 - searchRange;\n\t      directory = new Data;\n\t      directory.writeInt(this.scalarType);\n\t      directory.writeShort(tableCount);\n\t      directory.writeShort(searchRange);\n\t      directory.writeShort(entrySelector);\n\t      directory.writeShort(rangeShift);\n\t      directoryLength = tableCount * 16;\n\t      offset = directory.pos + directoryLength;\n\t      headOffset = null;\n\t      tableData = [];\n\t      for (tag in tables) {\n\t        table = tables[tag];\n\t        directory.writeString(tag);\n\t        directory.writeInt(checksum(table));\n\t        directory.writeInt(offset);\n\t        directory.writeInt(table.length);\n\t        tableData = tableData.concat(table);\n\t        if (tag === 'head') {\n\t          headOffset = offset;\n\t        }\n\t        offset += table.length;\n\t        while (offset % 4) {\n\t          tableData.push(0);\n\t          offset++;\n\t        }\n\t      }\n\t      directory.write(tableData);\n\t      sum = checksum(directory.data);\n\t      adjustment = 0xB1B0AFBA - sum;\n\t      directory.pos = headOffset + 8;\n\t      directory.writeUInt32(adjustment);\n\t      return new Buffer(directory.data);\n\t    };\n\n\t    checksum = function(data) {\n\t      var i, sum, tmp, _i, _ref;\n\t      data = __slice.call(data);\n\t      while (data.length % 4) {\n\t        data.push(0);\n\t      }\n\t      tmp = new Data(data);\n\t      sum = 0;\n\t      for (i = _i = 0, _ref = data.length; _i < _ref; i = _i += 4) {\n\t        sum += tmp.readUInt32();\n\t      }\n\t      return sum & 0xFFFFFFFF;\n\t    };\n\n\t    return Directory;\n\n\t  })();\n\n\t  module.exports = Directory;\n\n\t}).call(this);\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Generated by CoffeeScript 1.7.1\n\t(function() {\n\t  var Data, NameEntry, NameTable, Table, utils,\n\t    __hasProp = {}.hasOwnProperty,\n\t    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n\t  Table = __webpack_require__(76);\n\n\t  Data = __webpack_require__(72);\n\n\t  utils = __webpack_require__(77);\n\n\t  NameTable = (function(_super) {\n\t    var subsetTag;\n\n\t    __extends(NameTable, _super);\n\n\t    function NameTable() {\n\t      return NameTable.__super__.constructor.apply(this, arguments);\n\t    }\n\n\t    NameTable.prototype.tag = 'name';\n\n\t    NameTable.prototype.parse = function(data) {\n\t      var count, entries, entry, format, i, name, stringOffset, strings, text, _i, _j, _len, _name;\n\t      data.pos = this.offset;\n\t      format = data.readShort();\n\t      count = data.readShort();\n\t      stringOffset = data.readShort();\n\t      entries = [];\n\t      for (i = _i = 0; 0 <= count ? _i < count : _i > count; i = 0 <= count ? ++_i : --_i) {\n\t        entries.push({\n\t          platformID: data.readShort(),\n\t          encodingID: data.readShort(),\n\t          languageID: data.readShort(),\n\t          nameID: data.readShort(),\n\t          length: data.readShort(),\n\t          offset: this.offset + stringOffset + data.readShort()\n\t        });\n\t      }\n\t      strings = {};\n\t      for (i = _j = 0, _len = entries.length; _j < _len; i = ++_j) {\n\t        entry = entries[i];\n\t        data.pos = entry.offset;\n\t        text = data.readString(entry.length);\n\t        name = new NameEntry(text, entry);\n\t        if (strings[_name = entry.nameID] == null) {\n\t          strings[_name] = [];\n\t        }\n\t        strings[entry.nameID].push(name);\n\t      }\n\t      this.strings = strings;\n\t      this.copyright = strings[0];\n\t      this.fontFamily = strings[1];\n\t      this.fontSubfamily = strings[2];\n\t      this.uniqueSubfamily = strings[3];\n\t      this.fontName = strings[4];\n\t      this.version = strings[5];\n\t      this.postscriptName = strings[6][0].raw.replace(/[\\x00-\\x19\\x80-\\xff]/g, \"\");\n\t      this.trademark = strings[7];\n\t      this.manufacturer = strings[8];\n\t      this.designer = strings[9];\n\t      this.description = strings[10];\n\t      this.vendorUrl = strings[11];\n\t      this.designerUrl = strings[12];\n\t      this.license = strings[13];\n\t      this.licenseUrl = strings[14];\n\t      this.preferredFamily = strings[15];\n\t      this.preferredSubfamily = strings[17];\n\t      this.compatibleFull = strings[18];\n\t      return this.sampleText = strings[19];\n\t    };\n\n\t    subsetTag = \"AAAAAA\";\n\n\t    NameTable.prototype.encode = function() {\n\t      var id, list, nameID, nameTable, postscriptName, strCount, strTable, string, strings, table, val, _i, _len, _ref;\n\t      strings = {};\n\t      _ref = this.strings;\n\t      for (id in _ref) {\n\t        val = _ref[id];\n\t        strings[id] = val;\n\t      }\n\t      postscriptName = new NameEntry(\"\" + subsetTag + \"+\" + this.postscriptName, {\n\t        platformID: 1,\n\t        encodingID: 0,\n\t        languageID: 0\n\t      });\n\t      strings[6] = [postscriptName];\n\t      subsetTag = utils.successorOf(subsetTag);\n\t      strCount = 0;\n\t      for (id in strings) {\n\t        list = strings[id];\n\t        if (list != null) {\n\t          strCount += list.length;\n\t        }\n\t      }\n\t      table = new Data;\n\t      strTable = new Data;\n\t      table.writeShort(0);\n\t      table.writeShort(strCount);\n\t      table.writeShort(6 + 12 * strCount);\n\t      for (nameID in strings) {\n\t        list = strings[nameID];\n\t        if (list != null) {\n\t          for (_i = 0, _len = list.length; _i < _len; _i++) {\n\t            string = list[_i];\n\t            table.writeShort(string.platformID);\n\t            table.writeShort(string.encodingID);\n\t            table.writeShort(string.languageID);\n\t            table.writeShort(nameID);\n\t            table.writeShort(string.length);\n\t            table.writeShort(strTable.pos);\n\t            strTable.writeString(string.raw);\n\t          }\n\t        }\n\t      }\n\t      return nameTable = {\n\t        postscriptName: postscriptName.raw,\n\t        table: table.data.concat(strTable.data)\n\t      };\n\t    };\n\n\t    return NameTable;\n\n\t  })(Table);\n\n\t  module.exports = NameTable;\n\n\t  NameEntry = (function() {\n\t    function NameEntry(raw, entry) {\n\t      this.raw = raw;\n\t      this.length = this.raw.length;\n\t      this.platformID = entry.platformID;\n\t      this.encodingID = entry.encodingID;\n\t      this.languageID = entry.languageID;\n\t    }\n\n\t    return NameEntry;\n\n\t  })();\n\n\t}).call(this);\n\n\n/***/ },\n/* 76 */\n/***/ function(module, exports) {\n\n\t// Generated by CoffeeScript 1.7.1\n\t(function() {\n\t  var Table;\n\n\t  Table = (function() {\n\t    function Table(file) {\n\t      var info;\n\t      this.file = file;\n\t      info = this.file.directory.tables[this.tag];\n\t      this.exists = !!info;\n\t      if (info) {\n\t        this.offset = info.offset, this.length = info.length;\n\t        this.parse(this.file.contents);\n\t      }\n\t    }\n\n\t    Table.prototype.parse = function() {};\n\n\t    Table.prototype.encode = function() {};\n\n\t    Table.prototype.raw = function() {\n\t      if (!this.exists) {\n\t        return null;\n\t      }\n\t      this.file.contents.pos = this.offset;\n\t      return this.file.contents.read(this.length);\n\t    };\n\n\t    return Table;\n\n\t  })();\n\n\t  module.exports = Table;\n\n\t}).call(this);\n\n\n/***/ },\n/* 77 */\n/***/ function(module, exports) {\n\n\t// Generated by CoffeeScript 1.7.1\n\n\t/*\n\t * An implementation of Ruby's string.succ method.\n\t * By Devon Govett\n\t *\n\t * Returns the successor to str. The successor is calculated by incrementing characters starting \n\t * from the rightmost alphanumeric (or the rightmost character if there are no alphanumerics) in the\n\t * string. Incrementing a digit always results in another digit, and incrementing a letter results in\n\t * another letter of the same case.\n\t *\n\t * If the increment generates a carry, the character to the left of it is incremented. This \n\t * process repeats until there is no carry, adding an additional character if necessary.\n\t *\n\t * succ(\"abcd\")      == \"abce\"\n\t * succ(\"THX1138\")   == \"THX1139\"\n\t * succ(\"<<koala>>\") == \"<<koalb>>\"\n\t * succ(\"1999zzz\")   == \"2000aaa\"\n\t * succ(\"ZZZ9999\")   == \"AAAA0000\"\n\t */\n\n\t(function() {\n\t  exports.successorOf = function(input) {\n\t    var added, alphabet, carry, i, index, isUpperCase, last, length, next, result;\n\t    alphabet = 'abcdefghijklmnopqrstuvwxyz';\n\t    length = alphabet.length;\n\t    result = input;\n\t    i = input.length;\n\t    while (i >= 0) {\n\t      last = input.charAt(--i);\n\t      if (isNaN(last)) {\n\t        index = alphabet.indexOf(last.toLowerCase());\n\t        if (index === -1) {\n\t          next = last;\n\t          carry = true;\n\t        } else {\n\t          next = alphabet.charAt((index + 1) % length);\n\t          isUpperCase = last === last.toUpperCase();\n\t          if (isUpperCase) {\n\t            next = next.toUpperCase();\n\t          }\n\t          carry = index + 1 >= length;\n\t          if (carry && i === 0) {\n\t            added = isUpperCase ? 'A' : 'a';\n\t            result = added + next + result.slice(1);\n\t            break;\n\t          }\n\t        }\n\t      } else {\n\t        next = +last + 1;\n\t        carry = next > 9;\n\t        if (carry) {\n\t          next = 0;\n\t        }\n\t        if (carry && i === 0) {\n\t          result = '1' + next + result.slice(1);\n\t          break;\n\t        }\n\t      }\n\t      result = result.slice(0, i) + next + result.slice(i + 1);\n\t      if (!carry) {\n\t        break;\n\t      }\n\t    }\n\t    return result;\n\t  };\n\n\t  exports.invert = function(object) {\n\t    var key, ret, val;\n\t    ret = {};\n\t    for (key in object) {\n\t      val = object[key];\n\t      ret[val] = key;\n\t    }\n\t    return ret;\n\t  };\n\n\t}).call(this);\n\n\n/***/ },\n/* 78 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Generated by CoffeeScript 1.7.1\n\t(function() {\n\t  var Data, HeadTable, Table,\n\t    __hasProp = {}.hasOwnProperty,\n\t    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n\t  Table = __webpack_require__(76);\n\n\t  Data = __webpack_require__(72);\n\n\t  HeadTable = (function(_super) {\n\t    __extends(HeadTable, _super);\n\n\t    function HeadTable() {\n\t      return HeadTable.__super__.constructor.apply(this, arguments);\n\t    }\n\n\t    HeadTable.prototype.tag = 'head';\n\n\t    HeadTable.prototype.parse = function(data) {\n\t      data.pos = this.offset;\n\t      this.version = data.readInt();\n\t      this.revision = data.readInt();\n\t      this.checkSumAdjustment = data.readInt();\n\t      this.magicNumber = data.readInt();\n\t      this.flags = data.readShort();\n\t      this.unitsPerEm = data.readShort();\n\t      this.created = data.readLongLong();\n\t      this.modified = data.readLongLong();\n\t      this.xMin = data.readShort();\n\t      this.yMin = data.readShort();\n\t      this.xMax = data.readShort();\n\t      this.yMax = data.readShort();\n\t      this.macStyle = data.readShort();\n\t      this.lowestRecPPEM = data.readShort();\n\t      this.fontDirectionHint = data.readShort();\n\t      this.indexToLocFormat = data.readShort();\n\t      return this.glyphDataFormat = data.readShort();\n\t    };\n\n\t    HeadTable.prototype.encode = function(loca) {\n\t      var table;\n\t      table = new Data;\n\t      table.writeInt(this.version);\n\t      table.writeInt(this.revision);\n\t      table.writeInt(this.checkSumAdjustment);\n\t      table.writeInt(this.magicNumber);\n\t      table.writeShort(this.flags);\n\t      table.writeShort(this.unitsPerEm);\n\t      table.writeLongLong(this.created);\n\t      table.writeLongLong(this.modified);\n\t      table.writeShort(this.xMin);\n\t      table.writeShort(this.yMin);\n\t      table.writeShort(this.xMax);\n\t      table.writeShort(this.yMax);\n\t      table.writeShort(this.macStyle);\n\t      table.writeShort(this.lowestRecPPEM);\n\t      table.writeShort(this.fontDirectionHint);\n\t      table.writeShort(loca.type);\n\t      table.writeShort(this.glyphDataFormat);\n\t      return table.data;\n\t    };\n\n\t    return HeadTable;\n\n\t  })(Table);\n\n\t  module.exports = HeadTable;\n\n\t}).call(this);\n\n\n/***/ },\n/* 79 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Generated by CoffeeScript 1.7.1\n\t(function() {\n\t  var CmapEntry, CmapTable, Data, Table,\n\t    __hasProp = {}.hasOwnProperty,\n\t    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n\t  Table = __webpack_require__(76);\n\n\t  Data = __webpack_require__(72);\n\n\t  CmapTable = (function(_super) {\n\t    __extends(CmapTable, _super);\n\n\t    function CmapTable() {\n\t      return CmapTable.__super__.constructor.apply(this, arguments);\n\t    }\n\n\t    CmapTable.prototype.tag = 'cmap';\n\n\t    CmapTable.prototype.parse = function(data) {\n\t      var entry, i, tableCount, _i;\n\t      data.pos = this.offset;\n\t      this.version = data.readUInt16();\n\t      tableCount = data.readUInt16();\n\t      this.tables = [];\n\t      this.unicode = null;\n\t      for (i = _i = 0; 0 <= tableCount ? _i < tableCount : _i > tableCount; i = 0 <= tableCount ? ++_i : --_i) {\n\t        entry = new CmapEntry(data, this.offset);\n\t        this.tables.push(entry);\n\t        if (entry.isUnicode) {\n\t          if (this.unicode == null) {\n\t            this.unicode = entry;\n\t          }\n\t        }\n\t      }\n\t      return true;\n\t    };\n\n\t    CmapTable.encode = function(charmap, encoding) {\n\t      var result, table;\n\t      if (encoding == null) {\n\t        encoding = 'macroman';\n\t      }\n\t      result = CmapEntry.encode(charmap, encoding);\n\t      table = new Data;\n\t      table.writeUInt16(0);\n\t      table.writeUInt16(1);\n\t      result.table = table.data.concat(result.subtable);\n\t      return result;\n\t    };\n\n\t    return CmapTable;\n\n\t  })(Table);\n\n\t  CmapEntry = (function() {\n\t    function CmapEntry(data, offset) {\n\t      var code, count, endCode, glyphId, glyphIds, i, idDelta, idRangeOffset, index, saveOffset, segCount, segCountX2, start, startCode, tail, _i, _j, _k, _len;\n\t      this.platformID = data.readUInt16();\n\t      this.encodingID = data.readShort();\n\t      this.offset = offset + data.readInt();\n\t      saveOffset = data.pos;\n\t      data.pos = this.offset;\n\t      this.format = data.readUInt16();\n\t      this.length = data.readUInt16();\n\t      this.language = data.readUInt16();\n\t      this.isUnicode = (this.platformID === 3 && this.encodingID === 1 && this.format === 4) || this.platformID === 0 && this.format === 4;\n\t      this.codeMap = {};\n\t      switch (this.format) {\n\t        case 0:\n\t          for (i = _i = 0; _i < 256; i = ++_i) {\n\t            this.codeMap[i] = data.readByte();\n\t          }\n\t          break;\n\t        case 4:\n\t          segCountX2 = data.readUInt16();\n\t          segCount = segCountX2 / 2;\n\t          data.pos += 6;\n\t          endCode = (function() {\n\t            var _j, _results;\n\t            _results = [];\n\t            for (i = _j = 0; 0 <= segCount ? _j < segCount : _j > segCount; i = 0 <= segCount ? ++_j : --_j) {\n\t              _results.push(data.readUInt16());\n\t            }\n\t            return _results;\n\t          })();\n\t          data.pos += 2;\n\t          startCode = (function() {\n\t            var _j, _results;\n\t            _results = [];\n\t            for (i = _j = 0; 0 <= segCount ? _j < segCount : _j > segCount; i = 0 <= segCount ? ++_j : --_j) {\n\t              _results.push(data.readUInt16());\n\t            }\n\t            return _results;\n\t          })();\n\t          idDelta = (function() {\n\t            var _j, _results;\n\t            _results = [];\n\t            for (i = _j = 0; 0 <= segCount ? _j < segCount : _j > segCount; i = 0 <= segCount ? ++_j : --_j) {\n\t              _results.push(data.readUInt16());\n\t            }\n\t            return _results;\n\t          })();\n\t          idRangeOffset = (function() {\n\t            var _j, _results;\n\t            _results = [];\n\t            for (i = _j = 0; 0 <= segCount ? _j < segCount : _j > segCount; i = 0 <= segCount ? ++_j : --_j) {\n\t              _results.push(data.readUInt16());\n\t            }\n\t            return _results;\n\t          })();\n\t          count = (this.length - data.pos + this.offset) / 2;\n\t          glyphIds = (function() {\n\t            var _j, _results;\n\t            _results = [];\n\t            for (i = _j = 0; 0 <= count ? _j < count : _j > count; i = 0 <= count ? ++_j : --_j) {\n\t              _results.push(data.readUInt16());\n\t            }\n\t            return _results;\n\t          })();\n\t          for (i = _j = 0, _len = endCode.length; _j < _len; i = ++_j) {\n\t            tail = endCode[i];\n\t            start = startCode[i];\n\t            for (code = _k = start; start <= tail ? _k <= tail : _k >= tail; code = start <= tail ? ++_k : --_k) {\n\t              if (idRangeOffset[i] === 0) {\n\t                glyphId = code + idDelta[i];\n\t              } else {\n\t                index = idRangeOffset[i] / 2 + (code - start) - (segCount - i);\n\t                glyphId = glyphIds[index] || 0;\n\t                if (glyphId !== 0) {\n\t                  glyphId += idDelta[i];\n\t                }\n\t              }\n\t              this.codeMap[code] = glyphId & 0xFFFF;\n\t            }\n\t          }\n\t      }\n\t      data.pos = saveOffset;\n\t    }\n\n\t    CmapEntry.encode = function(charmap, encoding) {\n\t      var charMap, code, codeMap, codes, delta, deltas, diff, endCode, endCodes, entrySelector, glyphIDs, i, id, indexes, last, map, nextID, offset, old, rangeOffsets, rangeShift, result, searchRange, segCount, segCountX2, startCode, startCodes, startGlyph, subtable, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _m, _n, _name, _o, _p, _q;\n\t      subtable = new Data;\n\t      codes = Object.keys(charmap).sort(function(a, b) {\n\t        return a - b;\n\t      });\n\t      switch (encoding) {\n\t        case 'macroman':\n\t          