\n\t            args = [];\n\t            curArg = \"\";\n\t            foundDecimal = false;\n\t          }\n\t          cmd = c;\n\t        } else if ((c === \" \" || c === \",\") || (c === \"-\" && curArg.length > 0 && curArg[curArg.length - 1] !== 'e') || (c === \".\" && foundDecimal)) {\n\t          if (curArg.length === 0) {\n\t            continue;\n\t          }\n\t          if (args.length === params) {\n\t            ret[ret.length] = {\n\t              cmd: cmd,\n\t              args: args\n\t            };\n\t            args = [+curArg];\n\t            if (cmd === \"M\") {\n\t              cmd = \"L\";\n\t            }\n\t            if (cmd === \"m\") {\n\t              cmd = \"l\";\n\t            }\n\t          } else {\n\t            args[args.length] = +curArg;\n\t          }\n\t          foundDecimal = c === \".\";\n\t          curArg = c === '-' || c === '.' ? c : '';\n\t        } else {\n\t          curArg += c;\n\t          if (c === '.') {\n\t            foundDecimal = true;\n\t          }\n\t        }\n\t      }\n\t      if (curArg.length > 0) {\n\t        if (args.length === params) {\n\t          ret[ret.length] = {\n\t            cmd: cmd,\n\t            args: args\n\t          };\n\t          args = [+curArg];\n\t          if (cmd === \"M\") {\n\t            cmd = \"L\";\n\t          }\n\t          if (cmd === \"m\") {\n\t            cmd = \"l\";\n\t          }\n\t        } else {\n\t          args[args.length] = +curArg;\n\t        }\n\t      }\n\t      ret[ret.length] = {\n\t        cmd: cmd,\n\t        args: args\n\t      };\n\t      return ret;\n\t    };\n\n\t    cx = cy = px = py = sx = sy = 0;\n\n\t    apply = function(commands, doc) {\n\t      var c, i, _i, _len, _name;\n\t      cx = cy = px = py = sx = sy = 0;\n\t      for (i = _i = 0, _len = commands.length; _i < _len; i = ++_i) {\n\t        c = commands[i];\n\t        if (typeof runners[_name = c.cmd] === \"function\") {\n\t          runners[_name](doc, c.args);\n\t        }\n\t      }\n\t      return cx = cy = px = py = 0;\n\t    };\n\n\t    runners = {\n\t      M: function(doc, a) {\n\t        cx = a[0];\n\t        cy = a[1];\n\t        px = py = null;\n\t        sx = cx;\n\t        sy = cy;\n\t        return doc.moveTo(cx, cy);\n\t      },\n\t      m: function(doc, a) {\n\t        cx += a[0];\n\t        cy += a[1];\n\t        px = py = null;\n\t        sx = cx;\n\t        sy = cy;\n\t        return doc.moveTo(cx, cy);\n\t      },\n\t      C: function(doc, a) {\n\t        cx = a[4];\n\t        cy = a[5];\n\t        px = a[2];\n\t        py = a[3];\n\t        return doc.bezierCurveTo.apply(doc, a);\n\t      },\n\t      c: function(doc, a) {\n\t        doc.bezierCurveTo(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy, a[4] + cx, a[5] + cy);\n\t        px = cx + a[2];\n\t        py = cy + a[3];\n\t        cx += a[4];\n\t        return cy += a[5];\n\t      },\n\t      S: function(doc, a) {\n\t        if (px === null) {\n\t          px = cx;\n\t          py = cy;\n\t        }\n\t        doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), a[0], a[1], a[2], a[3]);\n\t        px = a[0];\n\t        py = a[1];\n\t        cx = a[2];\n\t        return cy = a[3];\n\t      },\n\t      s: function(doc, a) {\n\t        if (px === null) {\n\t          px = cx;\n\t          py = cy;\n\t        }\n\t        doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), cx + a[0], cy + a[1], cx + a[2], cy + a[3]);\n\t        px = cx + a[0];\n\t        py = cy + a[1];\n\t        cx += a[2];\n\t        return cy += a[3];\n\t      },\n\t      Q: function(doc, a) {\n\t        px = a[0];\n\t        py = a[1];\n\t        cx = a[2];\n\t        cy = a[3];\n\t        return doc.quadraticCurveTo(a[0], a[1], cx, cy);\n\t      },\n\t      q: function(doc, a) {\n\t        doc.quadraticCurveTo(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy);\n\t        px = cx + a[0];\n\t        py = cy + a[1];\n\t        cx += a[2];\n\t        return cy += a[3];\n\t      },\n\t      T: function(doc, a) {\n\t        if (px === null) {\n\t          px = cx;\n\t          py = cy;\n\t        } else {\n\t          px = cx - (px - cx);\n\t          py = cy - (py - cy);\n\t        }\n\t        doc.quadraticCurveTo(px, py, a[0], a[1]);\n\t        px = cx - (px - cx);\n\t        py = cy - (py - cy);\n\t        cx = a[0];\n\t        return cy = a[1];\n\t      },\n\t      t: function(doc, a) {\n\t        if (px === null) {\n\t          px = cx;\n\t          py = cy;\n\t        } else {\n\t          px = cx - (px - cx);\n\t          py = cy - (py - cy);\n\t        }\n\t        doc.quadraticCurveTo(px, py, cx + a[0], cy + a[1]);\n\t        cx += a[0];\n\t        return cy += a[1];\n\t      },\n\t      A: function(doc, a) {\n\t        solveArc(doc, cx, cy, a);\n\t        cx = a[5];\n\t        return cy = a[6];\n\t      },\n\t      a: function(doc, a) {\n\t        a[5] += cx;\n\t        a[6] += cy;\n\t        solveArc(doc, cx, cy, a);\n\t        cx = a[5];\n\t        return cy = a[6];\n\t      },\n\t      L: function(doc, a) {\n\t        cx = a[0];\n\t        cy = a[1];\n\t        px = py = null;\n\t        return doc.lineTo(cx, cy);\n\t      },\n\t      l: function(doc, a) {\n\t        cx += a[0];\n\t        cy += a[1];\n\t        px = py = null;\n\t        return doc.lineTo(cx, cy);\n\t      },\n\t      H: function(doc, a) {\n\t        cx = a[0];\n\t        px = py = null;\n\t        return doc.lineTo(cx, cy);\n\t      },\n\t      h: function(doc, a) {\n\t        cx += a[0];\n\t        px = py = null;\n\t        return doc.lineTo(cx, cy);\n\t      },\n\t      V: function(doc, a) {\n\t        cy = a[0];\n\t        px = py = null;\n\t        return doc.lineTo(cx, cy);\n\t      },\n\t      v: function(doc, a) {\n\t        cy += a[0];\n\t        px = py = null;\n\t        return doc.lineTo(cx, cy);\n\t      },\n\t      Z: function(doc) {\n\t        doc.closePath();\n\t        cx = sx;\n\t        return cy = sy;\n\t      },\n\t      z: function(doc) {\n\t        doc.closePath();\n\t        cx = sx;\n\t        return cy = sy;\n\t      }\n\t    };\n\n\t    solveArc = function(doc, x, y, coords) {\n\t      var bez, ex, ey, large, rot, rx, ry, seg, segs, sweep, _i, _len, _results;\n\t      rx = coords[0], ry = coords[1], rot = coords[2], large = coords[3], sweep = coords[4], ex = coords[5], ey = coords[6];\n\t      segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n\t      _results = [];\n\t      for (_i = 0, _len = segs.length; _i < _len; _i++) {\n\t        seg = segs[_i];\n\t        bez = segmentToBezier.apply(null, seg);\n\t        _results.push(doc.bezierCurveTo.apply(doc, bez));\n\t      }\n\t      return _results;\n\t    };\n\n\t    arcToSegments = function(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n\t      var a00, a01, a10, a11, cos_th, d, i, pl, result, segments, sfactor, sfactor_sq, sin_th, th, th0, th1, th2, th3, th_arc, x0, x1, xc, y0, y1, yc, _i;\n\t      th = rotateX * (Math.PI / 180);\n\t      sin_th = Math.sin(th);\n\t      cos_th = Math.cos(th);\n\t      rx = Math.abs(rx);\n\t      ry = Math.abs(ry);\n\t      px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n\t      py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n\t      pl = (px * px) / (rx * rx) + (py * py) / (ry * ry);\n\t      if (pl > 1) {\n\t        pl = Math.sqrt(pl);\n\t        rx *= pl;\n\t        ry *= pl;\n\t      }\n\t      a00 = cos_th / rx;\n\t      a01 = sin_th / rx;\n\t      a10 = (-sin_th) / ry;\n\t      a11 = cos_th / ry;\n\t      x0 = a00 * ox + a01 * oy;\n\t      y0 = a10 * ox + a11 * oy;\n\t      x1 = a00 * x + a01 * y;\n\t      y1 = a10 * x + a11 * y;\n\t      d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);\n\t      sfactor_sq = 1 / d - 0.25;\n\t      if (sfactor_sq < 0) {\n\t        sfactor_sq = 0;\n\t      }\n\t      sfactor = Math.sqrt(sfactor_sq);\n\t      if (sweep === large) {\n\t        sfactor = -sfactor;\n\t      }\n\t      xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);\n\t      yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);\n\t      th0 = Math.atan2(y0 - yc, x0 - xc);\n\t      th1 = Math.atan2(y1 - yc, x1 - xc);\n\t      th_arc = th1 - th0;\n\t      if (th_arc < 0 && sweep === 1) {\n\t        th_arc += 2 * Math.PI;\n\t      } else if (th_arc > 0 && sweep === 0) {\n\t        th_arc -= 2 * Math.PI;\n\t      }\n\t      segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));\n\t      result = [];\n\t      for (i = _i = 0; 0 <= segments ? _i < segments : _i > segments; i = 0 <= segments ? ++_i : --_i) {\n\t        th2 = th0 + i * th_arc / segments;\n\t        th3 = th0 + (i + 1) * th_arc / segments;\n\t        result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n\t      }\n\t      return result;\n\t    };\n\n\t    segmentToBezier = function(cx, cy, th0, th1, rx, ry, sin_th, cos_th) {\n\t      var a00, a01, a10, a11, t, th_half, x1, x2, x3, y1, y2, y3;\n\t      a00 = cos_th * rx;\n\t      a01 = -sin_th * ry;\n\t      a10 = sin_th * rx;\n\t      a11 = cos_th * ry;\n\t      th_half = 0.5 * (th1 - th0);\n\t      t = (8 / 3) * Math.sin(th_half * 0.5) * Math.sin(th_half * 0.5) / Math.sin(th_half);\n\t      x1 = cx + Math.cos(th0) - t * Math.sin(th0);\n\t      y1 = cy + Math.sin(th0) + t * Math.cos(th0);\n\t      x3 = cx + Math.cos(th1);\n\t      y3 = cy + Math.sin(th1);\n\t      x2 = x3 + t * Math.sin(th1);\n\t      y2 = y3 - t * Math.cos(th1);\n\t      return [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];\n\t    };\n\n\t    return SVGPath;\n\n\t  })();\n\n\t  module.exports = SVGPath;\n\n\t}).call(this);\n\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Generated by CoffeeScript 1.7.1\n\t(function() {\n\t  var PDFFont;\n\n\t  PDFFont = __webpack_require__(70);\n\n\t  module.exports = {\n\t    initFonts: function() {\n\t      this._fontFamilies = {};\n\t      this._fontCount = 0;\n\t      this._fontSize = 12;\n\t      this._font = null;\n\t      this._registeredFonts = {};\n\t      \n\t    },\n\t    font: function(src, family, size) {\n\t      var cacheKey, font, id, _ref;\n\t      if (typeof family === 'number') {\n\t        size = family;\n\t        family = null;\n\t      }\n\t      if (typeof src === 'string' && this._registeredFonts[src]) {\n\t        cacheKey = src;\n\t        _ref = this._registeredFonts[src], src = _ref.src, family = _ref.family;\n\t      } else {\n\t        cacheKey = family || src;\n\t        if (typeof cacheKey !== 'string') {\n\t          cacheKey = null;\n\t        }\n\t      }\n\t      if (size != null) {\n\t        this.fontSize(size);\n\t      }\n\t      if (font = this._fontFamilies[cacheKey]) {\n\t        this._font = font;\n\t        return this;\n\t      }\n\t      id = 'F' + (++this._fontCount);\n\t      this._font = new PDFFont(this, src, family, id);\n\t      if (font = this._fontFamilies[this._font.name]) {\n\t        this._font = font;\n\t        return this;\n\t      }\n\t      if (cacheKey) {\n\t        this._fontFamilies[cacheKey] = this._font;\n\t      }\n\t      this._fontFamilies[this._font.name] = this._font;\n\t      return this;\n\t    },\n\t    fontSize: function(_fontSize) {\n\t      this._fontSize = _fontSize;\n\t      return this;\n\t    },\n\t    currentLineHeight: function(includeGap) {\n\t      if (includeGap == null) {\n\t        includeGap = false;\n\t      }\n\t      return this._font.lineHeight(this._fontSize, includeGap);\n\t    },\n\t    registerFont: function(name, src, family) {\n\t      this._registeredFonts[name] = {\n\t        src: src,\n\t        family: family\n\t      };\n\t      return this;\n\t    }\n\t  };\n\n\t}).call(this);\n\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer, __dirname) {// Generated by CoffeeScript 1.7.1\n\n\t/*\n\tPDFFont - embeds fonts in PDF documents\n\tBy Devon Govett\n\t */\n\n\t(function() {\n\t  var AFMFont, PDFFont, Subset, TTFFont, fs;\n\n\t  TTFFont = __webpack_require__(71);\n\n\t  AFMFont = __webpack_require__(87);\n\n\t  Subset = __webpack_require__(88);\n\n\t  fs = __webpack_require__(44);\n\n\t  PDFFont = (function() {\n\t    var STANDARD_FONTS, toUnicodeCmap;\n\n\t    function PDFFont(document, src, family, id) {\n\t      th           GB: 'イギリス',
                GR: 'ギリシャ',
                HR: 'クロアチア',
                HU: 'ハンガリー',
                IE: 'アイルランド',
                IS: 'アイスランド',
                IT: 'イタリア',
                LT: 'リトアニア',
                LU: 'ルクセンブルグ',
                LV: 'ラトビア',
                MT: 'マルタ',
                NL: 'オランダ',
                NO: 'ノルウェー',
                PL: 'ポーランド',
                PT: 'ポルトガル',
                RO: 'ルーマニア',
                RS: 'セルビア',
                RU: 'ロシア',
                SE: 'スウェーデン',
                SI: 'スロベニア',
                SK: 'スロバキア',
                VE: 'ベネズエラ',
                ZA: '南アフリカ',
            },
            country: '有効な%sのVAT番号を入力してください',
            default: '有効なVAT番号を入力してください',
        },
        vin: {
            default: '有効なVIN番号を入力してください',
        },
        zipCode: {
            countries: {
                AT: 'オーストリア',
                BG: 'ブルガリア',
                BR: 'ブラジル',
                CA: 'カナダ',
                CH: 'スイス',
                CZ: 'チェコ共和国',
                DE: 'ドイツ',
                DK: 'デンマーク',
                ES: 'スペイン',
                FR: 'フランス',
                GB: 'イギリス',
                IE: 'アイルランド',
                IN: 'インド',
                IT: 'イタリア',
                MA: 'モロッコ',
                NL: 'オランダ',
                PL: 'ポーランド',
                PT: 'ポルトガル',
                RO: 'ルーマニア',
                RU: 'ロシア',
                SE: 'スウェーデン',
                SG: 'シンガポール',
                SK: 'スロバキア',
                US: 'アメリカ',
            },
            country: '有効な%sの郵便番号を入力してください',
            default: '有効な郵便番号を入力してください',
        },
    };
});
